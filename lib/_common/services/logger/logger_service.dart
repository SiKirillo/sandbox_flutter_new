import 'dart:convert';
import 'dart:io';
import 'dart:math' as math;

import 'package:dio/dio.dart';
import 'package:flutter/material.dart';
import 'package:path_provider/path_provider.dart';
import 'package:talker_bloc_logger/talker_bloc_logger.dart';
import 'package:talker_dio_logger/talker_dio_logger.dart';
import 'package:talker_flutter/talker_flutter.dart';
import 'package:bloc/bloc.dart';

import '../../common.dart';

part 'logger_provider.dart';
part 'logger_screen.dart';
part 'custom_bloc_observer.dart';
part 'custom_dio_observer.dart';
part 'custom_route_observer.dart';

/// Central logging via Talker: [init] configures Dio/Bloc/Route observers; use log* for custom messages.
class LoggerService {
  static final _talker = TalkerFlutter.init();
  static late final CustomDioLogger _talkerDio;
  static late final CustomBlocObserver _talkerBloc;
  static late final CustomRouteObserver _talkerRoute;

  static Talker get talker => _talker;
  static CustomDioLogger get talkerDio => _talkerDio;
  static CustomBlocObserver get talkerBloc => _talkerBloc;
  static CustomRouteObserver get talkerRoute => _talkerRoute;

  static final _pathsForIgnoreRequestLogs = <String>[];
  static final _pathsForIgnoreResponseLogs = <String>[];

  static void init({bool isEnabled = true}) {
    _talker.configure(
      settings: TalkerSettings(
        enabled: isEnabled,
      ),
    );

    _talkerDio = CustomDioLogger(
      talker: _talker,
      settings: TalkerDioLoggerSettings(
        printResponseHeaders: false,
        printErrorHeaders: false,
        printRequestHeaders: true,
        requestFilter: (options) => !_pathsForIgnoreRequestLogs.contains(options.path),
        responseFilter: (response) => !_pathsForIgnoreResponseLogs.contains(response.requestOptions.path),
      ),
    );

    _talkerBloc = CustomBlocObserver(
      talker: _talker,
      settings: TalkerBlocLoggerSettings(
        printEvents: true,
        printTransitions: false,
      ),
    );

    _talkerRoute = CustomRouteObserver(
      talker: _talker,
    );
  }

  static void logError(String message, {Object? exception, StackTrace? stackTrace}) {
    _talker.logCustom(_ErrorLog(message: message, exception: exception, stackTrace: stackTrace));
  }

  static void logWarning(String message, {Object? exception, StackTrace? stackTrace}) {
    _talker.logCustom(_WarningLog(message: message, exception: exception, stackTrace: stackTrace));
  }

  static void logSuccess(String message) {
    _talker.logCustom(_SuccessLog(message: message));
  }

  static void logInfo(String message) {
    _talker.logCustom(_InfoLog(message: message));
  }

  static void logTrace(String message) {
    _talker.logCustom(_TraceLog(message: message));
  }

  static Future<File?> getLogFile(DeviceData deviceData) async {
    if (_talker.history.isEmpty) return null;

    final buffer = StringBuffer();
    buffer.writeln('--------------------------------');
    buffer.writeln('DEVICE DATA:');
    buffer.writeln(deviceData.toString());
    buffer.writeln('--------------------------------');
    buffer.writeln('LOGS:');
    for (final log in talker.history) {
      buffer.writeln('*** [${log.time}] [${log.title}] ${log.displayMessage}');
    }
    buffer.writeln('--------------------------------');

    final temporalDirectory = await getTemporaryDirectory();
    final file = File('${temporalDirectory.path}/talker_logs_${DateTime.now().millisecondsSinceEpoch}.txt');
    await file.writeAsString(buffer.toString());
    return file;
  }

  /// Matches a stacktrace line as generated on Android/iOS devices
  static final _deviceStackTraceRegex = RegExp(r'#[0-9]+\s+(.+) \((\S+)\)');

  /// Matches a stacktrace line as generated by Flutter web
  static final _webStackTraceRegex = RegExp(r'^((packages|dart-sdk)/\S+/)');

  /// Matches a stacktrace line as generated by browser Dart
  static final _browserStackTraceRegex = RegExp(r'^(?:package:)?(dart:\S+|\S+)');

  static String? _formatStackTrace(StackTrace? stackTrace, int? maxCount) {
    final lines = stackTrace.toString().split('\n').where((line) => !_discardDeviceStacktraceLine(line) && !_discardWebStacktraceLine(line) && !_discardBrowserStacktraceLine(line) && line.isNotEmpty).toList();
    final formatted = [];

    final stackTraceLength = (maxCount != null ? math.min(lines.length, maxCount) : lines.length);
    for (int count = 0; count < stackTraceLength; count++) {
      final line = lines[count];
      formatted.add('#$count   ${line.replaceFirst(RegExp(r'#\d+\s+'), '')}');
    }

    if (formatted.isEmpty) {
      return null;
    } else {
      return formatted.join('\n');
    }
  }

  static bool _discardDeviceStacktraceLine(String line) {
    final match = _deviceStackTraceRegex.matchAsPrefix(line);
    if (match == null) {
      return false;
    }

    final segment = match.group(2)!;
    if (segment.startsWith('package:logger')) {
      return true;
    }

    return false;
  }

  static bool _discardWebStacktraceLine(String line) {
    final match = _webStackTraceRegex.matchAsPrefix(line);
    if (match == null) {
      return false;
    }

    final segment = match.group(1)!;
    if (segment.startsWith('packages/logger') || segment.startsWith('dart-sdk/lib')) {
      return true;
    }

    return false;
  }

  static bool _discardBrowserStacktraceLine(String line) {
    final match = _browserStackTraceRegex.matchAsPrefix(line);
    if (match == null) {
      return false;
    }

    final segment = match.group(1)!;
    if (segment.startsWith('package:logger') || segment.startsWith('dart:')) {
      return true;
    }

    return false;
  }

  static void addPathToIgnoreRequestLogs(String path) {
    if (!_pathsForIgnoreRequestLogs.contains(path)) {
      _pathsForIgnoreRequestLogs.add(path);
    }
  }

  static void addPathToIgnoreResponseLogs(String path) {
    if (!_pathsForIgnoreResponseLogs.contains(path)) {
      _pathsForIgnoreResponseLogs.add(path);
    }
  }
}

class _ErrorLog extends TalkerLog {
  _ErrorLog({
    required String message,
    Object? exception,
    StackTrace? stackTrace,
  }) : super(message, exception: exception, stackTrace: stackTrace);

  static const logKey = 'error_key';
  static final logColor = Color(0xFFFF0000);

  @override
  String get title => 'Error';

  @override
  String? get key => logKey;

  @override
  AnsiPen get pen => AnsiPen()..xterm(196);

  @override
  String generateTextMessage({TimeFormat timeFormat = TimeFormat.timeAndSeconds}) {
    final buffer = StringBuffer();
    buffer.write('â›” | [$title] | ${displayTime(timeFormat: timeFormat)}');
    buffer.write('\n$displayMessage$displayException');

    if (stackTrace != null) {
      buffer.write('\n${List.generate(109, (i) => '-').join()}');
      buffer.write('\n${LoggerService._formatStackTrace(stackTrace, 10) ?? ''}');
    }

    return buffer.toString();
  }
}

class _WarningLog extends TalkerLog {
  _WarningLog({
    required String message,
    Object? exception,
    StackTrace? stackTrace,
  }) : super(message, exception: exception, stackTrace: stackTrace);

  static const logKey = 'warning_key';
  static final logColor = Color(0xFFFF8700);

  @override
  String get title => 'Warning';

  @override
  String? get key => logKey;

  @override
  AnsiPen get pen => AnsiPen()..xterm(208);

  @override
  String generateTextMessage({TimeFormat timeFormat = TimeFormat.timeAndSeconds}) {
    final buffer = StringBuffer();
    buffer.write('ðŸš§ | [$title] | ${displayTime(timeFormat: timeFormat)}');
    buffer.write('\n$displayMessage$displayException');

    if (stackTrace != null) {
      buffer.write('\n${List.generate(109, (i) => '-').join()}');
      buffer.write('\n${LoggerService._formatStackTrace(stackTrace, 10) ?? ''}');
    }

    return buffer.toString();
  }
}

class _SuccessLog extends TalkerLog {
  _SuccessLog({required String message}) : super(message);

  static const logKey = 'success_key';
  static final logColor = Color(0xFF00FF00);

  @override
  String get title => 'Success';

  @override
  String? get key => logKey;

  @override
  AnsiPen get pen => AnsiPen()..xterm(046);

  @override
  String generateTextMessage({TimeFormat timeFormat = TimeFormat.timeAndSeconds}) {
    final buffer = StringBuffer();
    buffer.write('ðŸ’š | [$title] | ${displayTime(timeFormat: timeFormat)}');
    buffer.write('\n$displayMessage');
    return buffer.toString();
  }
}

class _InfoLog extends TalkerLog {
  _InfoLog({required String message}) : super(message);

  static const logKey = 'info_key';
  static final logColor = Color(0xFF00AFAF);

  @override
  String get title => 'Info';

  @override
  String? get key => logKey;

  @override
  AnsiPen get pen => AnsiPen()..xterm(037);

  @override
  String generateTextMessage({TimeFormat timeFormat = TimeFormat.timeAndSeconds}) {
    final buffer = StringBuffer();
    buffer.write('ðŸ“š | [$title] | ${displayTime(timeFormat: timeFormat)}');
    buffer.write('\n$displayMessage');
    return buffer.toString();
  }
}

class _TraceLog extends TalkerLog {
  _TraceLog({required String message}) : super(message);

  static const logKey = 'trace_key';
  static final logColor = Color(0xFFA8A8A8);

  @override
  String get title => 'Trace';

  @override
  String? get key => logKey;

  @override
  AnsiPen get pen => AnsiPen()..xterm(248);

  @override
  String generateTextMessage({TimeFormat timeFormat = TimeFormat.timeAndSeconds}) {
    final buffer = StringBuffer();
    buffer.write('ðŸ“£ | [$title] | ${displayTime(timeFormat: timeFormat)}');
    buffer.write('\n$displayMessage');
    return buffer.toString();
  }
}
